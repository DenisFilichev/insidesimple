# Задание
В БД создать пару sql табличек со связями (foreign keys)

Сделать HTTP POST эндпоинт, который получает данные в json вида:
{
    name: "имя отправителя"
    password: "пароль" 
}
этот эндпоинт проверяет пароль по БД и создает jwt токен (срок действия токена и алгоритм подписи не принципиален, для генерации и работе с токеном можно использовать готовую библиотечку) в токен записывает данные: name: "имя отправителя" 
и отправляет токен в ответ, тоже json вида:
{
    token: "тут сгенерированный токен" 
}

Сервер слушает и отвечает в какой-нибудь эндпоинт, в него на вход поступают данные в формате json:
Сообщения клиента-пользователя:
{
    name:       "имя отправителя",
    message:    "текст сообщение"
}
В заголовках указан Bearer токен, полученный из эндпоинта выше (между Bearer и полученным токеном должно быть нижнее подчеркивание).
Проверить токен, в случае успешной проверки токена, полученное сообщение сохранить в БД.

Если пришло сообщение вида:
{
    name:       "имя отправителя",
    message:    "history 10"
}
проверить токен, в случае успешной проверки токена отправить отправителю 10 последних сообщений из БД

Добавить описание и инструкцию по запуску и комментарии в коде, если изменяете формат сообщений, то подробное описание ендпоинтов и их полей.

Завернуть все компоненты в докер, покрыть код тестами.

Проект необходимо выкладывать на github и docker hub. Обязательно наличие readme-файла. 
При отсутствии полноценного readme-файла проверка тестового задания производиться не будет!

Порт 8080 НЕ УКАЗЫВАТЬ!!!

Составить запросы (curl) через терминал для проверки работоспособности вашей программы (приложить файл с запросами). 

#Описание
Для развертывания приложения необходимо настроить подключение к БД и liquibase в файле application.properties.

Реализованы REST-сервисы:
1) POST ../rest/reg - сервис доступен всем. Принимает JSON {"username":"admin","password":"admin"}. Проверяет имя, если такого пользователя не существует в БД, то создается новый. Пароль при записи в БД шифруется. Возвращает ответ:
{
    "id": 1,
    "username": "admin",
    "password": "$2a$10$wTZbXAFNHuM97U0ET1UVZu54foP8iBpQSHI0.icR7jdiqz3gY0Wfu",
    "messages": []
}

2) POST ../rest/login - сервис доступен всем. Принимает JSON {"username":"admin","password":"admin"}, при успешной авторизации возвращает JWT, вид ответа:
{
    "username": "admin",
    "token": "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhZG1pbjIiLCJpYXQiOjE2NTgzODI0NDAsImV4cCI6MTY1ODM4NjA0MH0.xzYiuJH4FDhfMFiXqXbhPt_FBoIZ7oooNDfU0bnJkzk"
}

3) GET ../rest/messages - сервис доступен только авторизованным пользователям. Авторизация происходит по JWT. Принимает JSON:
{"name":"admin","message":"history 10"}
Если содержимое ключа "message" состоит из слова history и следующего за ним числа, то возвращается ответ типа JSON в который включены сообщения указанного пользователя в количестве не более указанного числа, начиная с последнего сообщения в по убывающей.
Если в содержимом ключа "message" содержится иное, то это содержимое записывается в БД с указанием текущей даты и пользователя.
